<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" href="style.css">
<meta charset="UTF-8">
<meta name="viewport"
	content="width=device-width,initial-scale = 1.0" />
<script src="../../js/jquery-3.1.1.min.js"></script>
<title>캔버스 스터디(HTML Canvas Study)</title>
</head>
<body>

	<title>자바스크립트</title>
</head>
<body>

	<header>JQUERY</header>
	<section>
		<article>
			<h1 class="subject">자바스크립트로 Canvas 제어</h1>
			<h1>HTML 5 캔버스의 사용법</h1>
			<p>여기서는 HTML5 캔버스의 사용법 및 캔버스에 도형을 그리는 방법에 대해서 살펴본다.
				HTML5에서 제공하는 캔버스는 &lt;canvas&gt;태그를 사용해서 웹 페이지에 그래픽을
				그린다. 이때 자바스크립트를 사용해서 그때그때 그려지는 것들이 표시된다.
				&lt;canvas&gt;태그는 단지 그래픽을 그릴 수 있는 영역을 제공하는 컨테이너(그릇)로,
				실제로 그래픽을 그리기 위해서는 자바스크립트를 사용해야 한다. 캔버스는 각종 도형, 문자열 및 그림을
				그릴 수 있는 메소드를 제공한다. &lt;canvas&gt;태그는 현재 주요 웹 브라우저에서 대부분
				지원한다.</p>
			<h1>HTML 5 캔버스의 사용법</h1>
			<p>HTML5 캔버스를 사용하려면 &lt;canvas&gt;태그를 사용한다. 캔버스는 그래픽을
				그릴 수 있는 영역으로 너비(width)와 높이(height)를 속성으로 갖는다. 또한
				자바스크립트에서 캔버스를 제어하기 위해서는 id속성도 필요하다.</p>
			<div class="code">&lt;canvas id = "id" width = "너비"
				height = "높이"&gt;&lt;/canvas&gt;</div>
			<p>canvas 태그는 HTML 페이지에서 특정 구역을 정의하는데 쓰이는 div 태그안에
				넣어서 사용하는 것이 좋다. 캔버스에 표시할 마우스 포인터의 상대적인 위치등을 얻을 수 있기
				때문이다. 따라서 권장 형태르르 사용한 가로 300px, 세로 200px의 캔버스를 작성한 예시는
				다음과 같다.</p>
			<div class="code">&lt;canvas id = "canvas1" width =
				"300" height = "200" &gt;&lt;/canvas&gt;</div>
			<h1>캔버스 제어하기</h1>
			<p>여기서는 캔버스 영역에 그리기 위해 자바스크립트로 영역을 제어하는 방법을 살펴본다.
				앞에서는 canvas 태그를 사용해서 영역을 만드는 것을 살펴보았다. 만들어진 캔버스에 도형이나 그림
				등을 그리거나, 그려진 것들을 움직이게 만드는 등의 제어는 자바스크립트에서 한다.</p>
			<div class="code">
				&lt;script&gt;<br>//여기에 캔버스를 제어하는 코드를 입력한다.<br>&lt;/script&gt;
			</div>
			<p>자바스크립트는 HTML페이지가 모두 로드된 후에 사용되는 것이 좋기 때문에 캔버스를
				제어하는 코드도 $(document).ready()메소드 안에 기술한다.</p>
			<div class="code">
				&lt;script&gt;<br>$(document).ready(function(){ <br>//캔버스제어코드들<br>});<br>&lt;/script&gt;
			</div>
			<p>캔버스 제어 코드가 복잡한 경우 별도의 함수로 따로 정의해서 js파일로 작성한다.</p>
			<div class="code">
				&lt;script&gt;<br>$(document).ready(function(){<br>
				drawShape();//캔버스 제어 메소드 호출<br>});<br>function
				drawShape(){//캔버스 제어 메소드<br>//캔버스 제어 코드들<br>}<br>&lt;/script&gt;
			</div>
			<p>자바스크립트에서 캔버스를 제어하기 위해서는 먼저 2가지를 얻어내야 한다. 첫 번째가 그림이
				그려질 영역인 캔버스를 얻어내야 하고, 두 번째는 그리기 작업을 위한 그래픽 2D콘텍스트를 얻어내야
				한다. 다음과 같은 순서로 코딩된다.</p>
			<h2>1. 그림이 그려질 캔버스 영역 얻어내기</h2>
			<p>HTML 코드 부분에 정의한 &lt;canvas&gt;태그를 자바스크립트에서 제어할 수
				있도록 얻어낸다. 자바스크립트에서 HTML의 &lt;canvas id = "canvas1" width
				= "300" height = "200"&gt;&lt;/canvas&gt;과 같은 코드에서 캔버스를
				얻어내려면 id속성 값을 사용해서 유일한 태그에 접근해야 한다. 자바스크립트에서 id 속성의 값을
				얻어내려면 documnet.getElementById("id속성값") 또는
				$("#id속성값")[0]을 사용해서 한다. 만일 jQuery를사용한다면 var cvs =
				$("#canvas1")[0];과 같이 써서 canvas 엘리먼트 객체를 cvs 변수에 저장할 수
				있다.
			<div class="code">
				--JS--<br>$(document).ready(function(){<br>var
				cvs = $("#canvas1")[0]; -- ①<br>});<br> <br>
				--HTML--<br>&lt;cavnas id = "canvas1" width = "300"
				height = "200"&gt;&lt;/canvas&gt;
			</div>
			<h2>2. 그리기 작업을 위한 그래픽 2D콘텍스트 얻어내기</h2>
			<p>얻어낸 canvas 엘리먼트객체에서 getContext("2d"); 메소드를 사용해서
				2D콘텍스트를 얻어낸다.</p>
			<div class="code">
				--JS--<br>$(document).ready(function(){<br>var
				cvs = $("#canvas1")[0]; //①cvs는 canvas 엘리먼트 객체가 저장된 객체
				변수<br>var ctx = cvs.getContext("2d");//②그래픽 2D 콘텍스트
				얻어내기<br>}); <br> <br> --HTML-- <br>&lt;canvas
				id = "canvas1" width = "300" height =
				"200"&gt;&lt;/canvas&gt;<br>
			</div>
			<p>위의 코드들 다음엔느 실제로 그리는 작업을 수행하는 메소드를 사용하며, 이들은 다음절에서
				살펴본다.</p>

			<h1 class="subject">도형 문자열. 이미지 그리기</h1>
			<p>여기서는 캔버스에 도형, 문자열, 그림 그리기 등의 그리기 메소드를 살펴보고, 그리는
				바업을 예제를 통해 학습한다.</p>
			<p>캔버스에 그리기 위해서 ① canvas 엘리먼트 객체를 얻어내고, 이 얻어낸 객체의
				getContext("2d") 메소드를 사용해서 ②2D콘텐스트 객체를 얻어내고 나면 이제 ③그리기
				메소드를 사용해서 그리기 작업을 할 수 있다. 그리기 관련 메소드들은 [2D 콘텍스트 객체, 그리기
				메소드()]와 같은 형태로 사용한다.</p>
			<div class="code">
				$(document).ready(function(){<br>var cvs =
				$("#canvas1")[0];//①캔버스 객체를 얻어냄<br> var ctx =
				cvs.getContext("2d");//②캔버스 객체로부터 2D콘텍스트 객체를 얻어냄<br>
				//(10,10)좌표에 가로 80 , 세로 50 크기의 채워진 사각형을 그린다.<br>
				etx.fillRect(10,10,80,50); //③캔버스 객체로부터 2D콘텍스트 객체를 얻어냄 <br>});
			</div>

			<p>그리기의 가장 기본이 되는 주요 속성 및 메소드는 다음과 같다. (좀 더 자세한 사항은
				http://www.w3schools.com/tags/ref_canvas.asp 또는
				https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial을
				참조한다.)</p>
			<br>
			<table>
				<tr>
					<th>속성</th>
					<th>설명</th>
				</tr>
				<tr>
					<td>data</td>
					<td>주어진 이미지 데이터가 포함된 ImageData 객체를 리턴<br> 빈
						ImageData 객체를 생성 후에 파랑색을 지정하고 화면에 출력: 화면에 파란 사각형 출력<br>
						//가로 100, 세로 100의 빈 ImageData 객체 생성<br>var
						imgData = ctx.createimageData(100,100);<br>
						imgData.data[i+0] = 0; //R: 빨강색<br>
						imgData.data[i+1] = 0; //G: 초록색<br>
						imgData.data[i+2] = 255; //B: 파랑색<br> //0-완전투명,
						255-완전 불투명<br> imgData.data[i+3] = 255;
						//Alpha:투명도<br> ctx.putImageData(imgData,20,20);
						//화면에 이미지 출력

					</td>
				</tr>
				<tr>
					<td>fillStyle</td>
					<td>색, 그러데이션, 패턴 등으로 채우기를 지정하거나 얻어냄.예))도형의 채우기 색을
						초록색으로 지정<br>ctx.fillStyle = "#00FF00";
					</td>
				</tr>
				<tr>
					<td>font</td>
					<td>텍스트 폰트를 지정하거나 얻어냄.<br> 예))40px 크기의 Arial
						폰트를 갖는 글꼴을 지정<br> ctx.font = "40px.Arial";//글꼴
						크기와 폰트 지정<br> //(10,10)좌표에 40px 크기의 Arial 폰트를 갖는
						"테스트 출력 <br> ctx.fillText("테스트",10,10);
					</td>
				</tr>
				<tr>
					<td>height</td>
					<td>ImageData 객체의 높이(이미지의 세로 높이)를 얻어냄.<br>
						예))ImageData 객체의 높이를 알림상자에 표시<br> var ImgData =
						ctx.createImageData(100,100); alert(imgData.height);
					</td>
				</tr>
				<tr>
					<td>lineCap</td>
					<td>선의 끝 모양의 스타일을 지정하거나 얻어냄. 끝 모양에는 butt(평평한 끝모양),
						round(butt+라운드 사각형), square(butt + 사각형)가 있음. round와
						square가 butt보다 좀 더 길다.<br>ctx.lineCap = "butt";<br>ctx.lineCap
						= "round";<br>ctx.lineCap = "square";
					</td>
				</tr>
				<tr>
					<td>lineJoin</td>
					<td>두 선이 모서리 부분에서 만났을 때의 모양을 지정하거나 얻어냄. bevel,
						round, miter가 있음.<br> ctx.lineJoin = "bevel";//아주
						약간 비스듬함<br> ctx.lineJoin = "round";//완전히 둥금<br>
						ctx.lineJoin = "miter";//이건 완전히 각이 진것이고
					</td>
				</tr>
				<tr>
					<td>lineWidth</td>
					<td>선의 두께를 지정하거나 얻어냄.<br>예))선의 두께를 5픽셀로 지정<br>ctx.lineWidth
						= 5;
					</td>
				</tr>
				<tr>
					<td>miterLimit</td>
					<td>최대 miter값을 지정하거나 얻어냄. miter값은 안쪽 코너에서 바깥쪽 코너간의
						거리<br> 그러니까 모서리 부분의 테두리 부분 굵기를 의미한다.<br>
						예))최대 miter 값을 10으로 지정. ctx.miter=10;//10이 기본값
					</td>
				</tr>
				<tr>
					<td>shadowBlur</td>
					<td>그림자의 퍼짐(번짐) 값을 지정하거나 얻어냄. 숫자가 클수록 더 퍼짐.<br>
						예))그림자의 퍼짐을 10으로 지정<br> ctx.shadowBlur =10;
					</td>
				</tr>
				<tr>
					<td>shadowColor</td>
					<td>그림자의 색을 지정하거나 얻어냄.<br> 예))그림자의 색을 회색으로 지정<br>
						ctx.shadowColor ="gray";
					</td>
				</tr>
				<tr>
					<td>shadowOffsetX</td>
					<td>도형으로부터 그림자의 수평 거리를 지정하거나 얻어냄. 숫자가 커질수록 그림자가
						가로로 길어진다.<br>예))그림자의 가로 길이를 10으로 지정<br>
						ctx.shadowOffsetX = 10;
					</td>
				</tr>
				<tr>
					<td>shadowOffsetY</td>
					<td>도형으로부터 그림자의 수직 거리를 지정하거나 얻어냄. 숫자가 커질수록 그림자가
						세로로 길어진다.<br>예))그림자의 세로 길이를 10으로 지정<br>
						ctx.shadowOffsetY = 10;
					</td>
				</tr>
				<tr>
					<td>strokeStyle</td>
					<td>도형이나 글자의 테두리 선에 사용되는 선 색을 지정하거나 얻어냄<br>예))선색을
						검정색으로 지정<br> ctx.strokeStyle = "#000000";
					</td>
				</tr>
				<tr>
					<td>textAlign</td>
					<td>텍스트의 맞춤을 지정하거나 얻어냄. center, left, right,
						start가 있다. left와 start는 같으며,지정한 좌표를 중심으로 왼쪽 맞춤을 한다.
						right와 end는 같으며, 지정한 좌표를 중심으로 오른쪽 맞춤을 한다. center는 지정한
						좌표를 중심으로 가운데 맞춤을 한다. <br>예))(100,50)좌표에 왼쪽 맞춤으로
						문자열 그리기 <br> ctx.textAlign = 'left';//왼쪽 맞춤<br>
						ctx.fillText('test',100,50); (100,50)좌표에 문자열 그리기

					</td>
				</tr>
				<tr>
					<td>textBaseline</td>
					<td>텍스트의 베이스 라인을 지정하거나 얻어냄. alphabetic, top,
						hanging, middle, ideographic, bottom이 있다.<br> <img
						alt="alphabetic" src="../images/img_textbaseline.gif"><br>
						예))문자열의 베이스라인 지정<br> ctx.textBaseline =
						"alphabetic";//기본값으로 지정
					</td>
				</tr>
				<tr>
					<td>width</td>
					<td>ImageData 객체의 너비(이미지가로의 너비)를 얻어냄.<br>
						예))ImageData 객체의 너비를 알림 상자에 표시 <br> var imgData =
						ctx.createImageData(100,100);<br>
						alert(imgData.width);<br>
					</td>
				</tr>
			</table>
			<h1>캔버스의 그리기 관련 메소드들</h1>
			<table>
				<tr>
					<td>addColorStop()</td>
					<td>그러데이션에서 색상과 중단 위치를 설정한다.<br>예))//선형그라데이션
						생성<br>var grad =
						ctx.createLinearGradient(0,0,180,0);//x좌표,y좌표,가로축 그라디언트, 세로축 그라디언트<br>
						grad.addColorStop(0,"blue");//제1 색상 지점<br>
						grad.addColorStop(1,"white");//제2 색상 지점<br>
						ctx.fillStyle = grad; //채우기 색으로 그러데이션 지정<br>
						ctx.fillRect(20,20,200,100);//채워진 사각형 그린다.
					</td>
				</tr>
				<tr>
					<td>arc()</td>
					<td>호를 그린다.<br> 예))(175,175) 좌표에 반지름
						50,0~Math.PI*2(360도)로 그려지는 호를 그린다. 0~Math.PI*2(360도)는
						원이 됨.<br> ctx.arc(175,175,50,0,Math.PI*2,true);
					</td>
				</tr>
				<tr>
					<td>arcTo()</td>
					<td>두 탄젠트 사이의 호를 그린다.<br> 예))시작호의 (155,20)
						좌표, 끝 호의 (150,80)좌표에 반지름 60의 호<br>
						ctx.arcTo(150,20,150,80,60);
					</td>
				</tr>
				<tr>
					<td>beginPath()</td>
					<td>다각선의 시작선을 그리거나 현재의 선을 재설정한다.<br>예))ctx.beginPath();
					</td>
				</tr>
				<tr>
					<td>bezierCurveTo()</td>
					<td>큐빅 베지어 곡선을 생성한다.<br> <img alt="큐빅베지어"
						src="../images/cubic_basia.png"><br>
						ctx.beginPath(); ctx.moveTo(30,30);
						ctx.bezierCurveTo(10,150,250,150,250,10);
					</td>
				</tr>
				<tr>
					<td>clip()</td>
					<td>원래의 캔버스 영역으로부터 일부의 영역을 얻어낸다.<br>
						예))ctx.clip();
					</td>
				</tr>
				<tr>
					<td>closePath()</td>
					<td>현재의 선을 다각선의 시작점으로 연결한다. 도형 등을 그릴 때 마지막 선이 시작점과
						연결되어야 도형이 이루어진다. 채워진 도형을 그릴 때는 생략해도 된다.<br>
						예))ctx.closePath();
					</td>
				</tr>
				<tr>
					<td>createImageData()</td>
					<td>빈 ImageData 객체를 생성한다.<br> 예))가로 100, 세로
						100픽셀 크기의 빈 ImageData 객체 생성<br> var imgData =
						ctx.createImageData(100,100);
					</td>
				</tr>
				<tr>
					<td>createLinearGradient()</td>
					<td>선형 그러데이션을 생성한다.<br> 예))var grad =
						ctx.createLinearGradinet(0,0,180,0);
					</td>
				</tr>
				<tr>
					<td>createPattern()</td>
					<td>패턴을 생성한다. 패턴 이미지는 repeat, repeat-x,
						repeat-y,no-repeat를 사용해서 반복 여부를 결정<br> 예))패턴을
						생성하고 적용<br> var image = new Image();<br>
						image.src="b2s.png";<br> image.onload =
						function(){<br> var ptn =
						ctx.createPattern(image,'repeat');<br>
						ctx.rect(0,0,200,100);<br> ctx.fillStyle = ptn;<br>
						ctx.fill();<br> }<br>
					</td>
				</tr>
				<tr>
					<td>drawImage()</td>
					<td>캔버스 상에 이미지, 동영상, 다른 캔버스 등을 그린다(표시한다)<br>
						예))이미지 객체를 생성하고 이미지를 그린다.<br> var image = new
						Image();//Image 객체 생성<br>
						image.src="picture3.png";//이미지 파일 지정<br>
						image.onload = function(){//이미지가 로딩되면 자동 실행<br>
						tx.drawImage(image,0,0,width,height);//이미지를 그린다.<br>}
					</td>
				</tr>
				<tr>
					<td>fill()</td>
					<td>도형을 채우기 한다.<br>예))ctx.fill();
					</td>
				</tr>
				<tr>
					<td>fillRect()</td>
					<td>채우기 된 사각형을 그린다.<br>예))ctx.fillRect(10,10,80,50);
					</td>
				</tr>
				<tr>
					<td>fillText()</td>
					<td>채우기 된 글자를 그린다.<br>예))ctx.fillRect("테스트",300,50);
					</td>
				</tr>
				<tr>
					<td>getImageData()</td>
					<td>ImageData객체를 리턴한다.<br>예))(10,10) 좌표의 이미지를
						imgData 객체로 얻어내서 imgData에 저장<br>var imgData
						=ctx.getImageData(10,10,20,20);
					</td>
				</tr>
				<tr>
					<td>isPointInPath()</td>
					<td>주어진 포인트가 현재의 포인트이면 true값을 리턴한다.<br>
						예))if(ctx.isPointInPath(30,100)){}
					</td>
				</tr>
				<tr>
					<td>lineTo()</td>
					<td>다각선/다각형을 그릴 때 선을 추가한다. 이렇게 선을 추갛서 다각선/다각형이
						만들어진다.<br> 예))ctx.lineTo(100,175);
					</td>
				</tr>
				<tr>
					<td>measureText()</td>
					<td>문자열 객체를 얻어낸다.<br> 예))var str1 = "test";<br>
						alert(ctx.measureText(str1).width);
					</td>
				</tr>
				<tr>
					<td>moveTo()</td>
					<td>선을 추가하지 않고 포인트를 이동한다.<br>
						예))ctx.moveTo(75,150);
					</td>
				</tr>
				<tr>
					<td>putImageData()</td>
					<td>이미지 데이터를 캔버스에 넣는다. 화면에 생성된 이미지 데이터(이미지)를 출력한다.<br>예))(10,100)좌표에
						imgData 객체가 가진 내용(이미지)을 출력한다.<br>ctx.putImageData(imgData,10,100);
					</td>
				</tr>
				<tr>
					<td>quadraticCurveTo()</td>
					<td>이차 베지어 곡선을 생성한다.<br>//이미지 넣자 여기에<br>ctx.moveTo(10,10);<br>ctx.quadraticCurveTo(100,100,150,10);
					</td>
				</tr>
				<tr>
					<td>rect()</td>
					<td>사각형을 생성한다. fill()메소드나 stroke()메소드를 사용해서 채우거나
						그려야 사각형이 화면에 표시된다.<br>예)ctx.rect(0,0,200,100);
					</td>
				</tr>
				<tr>
					<td>restore()</td>
					<td>전에 저장된 경로 상태와 속성을 얻어낸다. save()메소드를 사용해서 저장한
						스타일 등을 다시 재사용할 때 사용. save()와 쌍으로 restore()메소드가 바로 직전에
						사용된 save()와 매치됨.<br>예))//원래 스타일 -검은색, 기본값<br>
						ctx.fillRect(0,0,100,100);//원래 스타일로 그린 검게 채워진 사각형<br>
						ctx.save();//원래 스타일 저장:1<br> ctx.fillStyle =
						'#0000FF';//새 스타일1 - 파랑색<br>
						ctx.fillRect(110,0,100,100);//새 스타일 1로 그린 파랗게 채워진 사각형<br>
						ctx.save();//새 스타일1 저장:2<br> ctx.restore();//바로
						전에 저장된 save()스타일 적용: 2, 파랑<br> ctx.restore();//전에
						전에 저장된 save()스타일 적용: 1, 검정<br>
						ctx.fillRect(220,0,100,100);//원래 스타일로 그린 검게 채워진 사각형<br>
					</td>
				</tr>
				<tr>
					<td>rotate()</td>
					<td>(도형 등을)회전한다. 각도(angle)는 도(degree)가 아니라
						라디안(radian, 호도)이기 때문에 radian - (Math.PI/180)*degree와
						같이 변환해서 상요한다. 즉, rotate((Math.PI/180)*degree)과 같은 형태로
						사용한다.<br>예)) ctx.fillStyle = "#DBDBDB";<br>
						ctx.fillRect(100,100,100,100);//원래 형태의 사각형<br>
						ctx.rotate((Math.PI/180)*5); //회전<br>
						ctx.fillStyle = "#000000";<br>
						ctx.fillRect(100,100,100,100); //회전 후 사각형
					</td>
				</tr>
				<tr>
					<td>save()</td>
					<td>현재의 내용을 저장한다. restore() 메소드와 쌍으로 사용됨.<br>
						ctx.fillRect(0,0,100,100);<br> ctx.save();
					</td>
				</tr>
				<tr>
					<td>scale()</td>
					<td>(도형 등의)크기를 조정한다. scale(가로배수, 세로배수)와 같이 사용하며,
						scale()메소드를 사용한 후에는 같은 크기의 도형도 조정된 크기로 표현한다.<br>
						ctx.strokeRect(10,10,30,20);<br> ctx.scale(2,2);
						//가로, 세로 2배 크기 조정<br>
						ctx.strokeRect(10,10,30,20);<br>
					</td>
				</tr>
				<tr>
					<td>setTransform()</td>
					<td>현재의 트랜스폼을 재설정하고 transform()메소드가 자동실행된다.
						setTransform(scaleX, skewX,skewY,scaleY,moveX,moveY)와
						같은 형태로 사용한다.<br>//가로 1배 확대, 가로 0.1, 세로-0.1 왜곡, 세로
						1배 확대, 가로 30, 세로 10 이동<br> ctx.fillStyle =
						"gray";<br> ctx.fillRect(0,0,200,100)//회색 사각형<br>
						ctx.setTransform(1,0.1,-0.1,1,30,10);//트랜스폼<br>
						ctx.fillStyle = "black";<br>
						ctx.fillRect(0,0,200,100);//트랜스폼된 검은 사각형<br>
					</td>
				</tr>

				<tr>
					<td>stroke()</td>
					<td>선을 그린다.<br> 예))ctx.stroke();
					</td>
				</tr>
				<tr>
					<td>strokeRect()</td>
					<td>채워지지 않은 사각형을 그린다.<br>
						예))ctx.strokeRect(100,10,80,50);
					</td>
				</tr>
				<tr>
					<td>strokeText()</td>
					<td>채워지지 않은 글자를 그린다.<br>
						예))ctx.strokeText("Hello",200,50);
					</td>
				</tr>
				<tr>
					<td>transform()</td>
					<td>현재의 트랜스폼을 대체한다.
						transform()scaleX,skewX,skewY,scaleY,moveX,moveY)와 같은
						형태로 사용한다.<br> 예))단독으로 쓰이면 setTransform()을 쓰는 것과
						같다.<br> ctx.transform(1,0.1,-0.1,1,30,10);
					</td>
				</tr>
				<tr>
					<td>translate()</td>
					<td>캔버스의(0,0)위치를 지정한 좌표로 이동한다. translate(x,y)와 같이
						사용하며, 시작 좌표는 (x,y)로 재설정한다.<br>
						예))ctx.fillRect(10,1,50,50);<br>
						ctx.translate(100,50);//시작 좌표(100,50)으로 이동<br>
						ctx.fillRect(10,10,50,50);
					</td>
				</tr>



			</table>

			<h1>p01에 연습 하나 하기</h1>
			<h1>p02에 연습 하나 더 추가 (이미지 나타내기)</h1>
			<h1 class="subject">2. 캔버스를 사용한 에니메이션</h1>
			<p>
				지금까지 우리는 자바스크립트를 사용해서 &lt;canvas&gt;태그를 제어했다. 마찬가지로
				상호동작하는 에니메이션도 자바스크립트를 사용해서 쉽게 만들 수 있다. 여기서는
				&lt;canvas&gt;태그와 자바스크립트를 사용해서 에니메이션을 구현하는 방법을 학습한다.<br>일단
				그려진 그림은 고정적으로 그려진 그 상태를 유지한다. 만일 그림을 움직이게 하고 싶다면 그려진 그림을
				지우고 다시 그리는 작업을 한다. 이것은 모든 그래픽에서 에니메이션을 구현하는 기본 구조이다. 따라서
				복잡한 형태를 다시 그리는 것은 많은 시간이 걸리며, 이것의 작업의 속도는 컴퓨터의 성능에 좌우된다.
				즉, 에니메이션 작업은 많은 리소스가 필요하다.
			</p>

			<h1>캔버스에서 에니메이션을 구현하는 순서</h1>
			<p>에니메이션을 구현하려면 기본적으로 다음의 순서에 따라 프로그래밍 한다.</p>
			<h2>1.캔버스 클리어</h2>
			<p>배경 이미지처럼 캔버스 전체를 채우는 형태를 그리지 않는 한, 어떤 모양을 그리든지 그리기
				전에 캔버스를 클리어하는 것이 필요하다. 이 작업은 clearRect()메소드를 사용한다.</p>
			<div class="code">
				//캔버스 클리어 예시<br>ctx.clearRect(0,0,300,300);
			</div>
			<h1>캔버스 상태 저장</h1>
			<p>어떤 설정을 변경하면 캔버스 상태에 영향을 미치기 때문에 원래 상태를 저장해 두어야한다.
				이 작업은 save()메소드를 사용한다.</p>
			<h1>에니메이션으로 만들 형태 그리기</h1>
			<p>여기서는 실제로 에니메이션에 필요한 작업을 캔버스의 그리기 관련 메소드를 사용해서 한다.</p>
			<div class="code">
				//에니메이션으로 만들 형태 그리기 예시<br>생략..<br>ctx.drawImage(img,x,y,iWidth,iHeight);<br>생략..
			</div>

			<h1>캔버스의 상태 재저장</h1>
			<p>새 형태를 더 그려야 할 경우 먼저 기존 상태를 재저장한다. 이 작업은
				restore()메소드를 사용한다.</p>
			<div class="code">
				//캔버스 상태 재저장 예시<br>ctx.restore();
			</div>
			<h1>에니메이션 제어</h1>
			<p>
				캔버스에 메소드를 사용해서 원하는 형태를 그린다. 이 메소드는 직접 사용하거나 사용자 정의 함수에서
				호출해서 사용한다. 일반적으로 스크립트의 실행이 끝나면 실행된 결과를 확인할 수 있다. 따라서 우리가
				임의로 애니메이션을 실행 및 제어하기 위해서는 특정 시간에 자동 호출되는
				window.setInterval(), window.setTimeout(),
				window.requestAnimationFrame()과 같은 애니메이션 동작(실행) 제어 함수가
				필요하다.<br>애니메이션 동작(실행) 제어함수는 다음과 같다.
			</p>

			<h2>setInterval(function, delay)메소드</h2>
			<p>특정시간(delay)마다 지정한 함수(function)을 반복 실행한다. 이때
				delay값은 1/1000초(밀리세컨드, millisecond, ms)값으로 지정하며, 예를 들어
				500은 0.5초이다.</p>
			<div class="code">setInterval(draw,50);//0.05초마다
				draw()함수를 실행</div>
			<h2>setTimeout(function,delay)메소드</h2>
			<p>지정한 함수(function)를 특정시간(delay)동안 실행한다. 이때 delay값은
				1/1000초로 지정한다.</p>
			<div class="code">window.setTimeout(displayAlert,1000);
				//displayAlert()함수를 1초 동안 실행</div>
			<h2>requestAnimationFrame(callback)메소드</h2>
			<p>지정한 함수(callback)을 호출해서 실행한다.</p>
			<div class="code">window.requestAnimationFrame(draw);//draw함수
				호출</div>
			<h1>연습 03에서 이미지 롤링 실행</h1>
			<h1>연습04에서 아날로그 시계 에니메이션</h1>
		</article>
	</section>
	<footer></footer>


</body>
</html>